program bandstructure
  use parameters
  use m_system_3d
  implicit none

  character(80):: infile, basename, infile_mom4, infile_mom4_2
  integer:: nqpoints_inp, nqpoints2, nqpoints
  real(kind=wp), allocatable:: qpoints_inp(:,:), qpoints(:,:)
  real(kind=wp), allocatable:: fc(:,:), band(:,:)
  
  complex(kind=wp):: fc_q(3,3)
  real(kind=wp):: fc_q_real(3,3), eig(3), eigvec(3,3), fc_q2(3,3)
  real(kind=wp):: qp(3), vec(3)
  integer:: supercell(3), cell1(3), cell2(3), cell12(3)
  integer:: ndisp, cellnum1, cellnum2
  integer:: i,j, i1,i2,i3,i4,i5,q,n, R, R_max, sign1, sign2, sign3, f1,f2, f3, j1,j2,j3
  integer:: ii, jj, xyz
  logical:: mom4_flag
  real(kind=wp), allocatable::qpoints_4_mom(:,:), dyn_mat2(:,:,:,:)  
  real(kind=wp):: mom4_gamma(3)

  ! read input
  read(5,*) infile
  read(5,*) infile_mom4
  read(5,*) infile_mom4_2
  read(5,*) basename
  read(5,*) mom4_flag
  read(5,*) nqpoints_inp, nqpoints2 
  
  allocate(qpoints_inp(nqpoints_inp,3))
  do i=1,nqpoints_inp
     read(5,*) qpoints_inp(i,:)
  end do
  
  ! read dynamical matrix
  open(unit=10, file=infile, status='old')
  
  read(10,*) supercell
  ndisp =3*product(supercell)
  allocate( fc(ndisp, 21))
  
  read(10,*) fc
  
  close(10)

  
  ! make the path in q-space
  nqpoints = (nqpoints_inp -1) * nqpoints2 +1
  allocate(qpoints(nqpoints,3), band(nqpoints,3))
  
  
  n=1
  do i=1, nqpoints_inp-1
     vec = qpoints_inp(i+1,:) - qpoints_inp(i,:) 
     
     do j=1,nqpoints2
        qpoints(n,:) = qpoints_inp(i,:) + (dfloat(j-1) / nqpoints2) * vec
        n=n+1
     end do
  end do
  qpoints(nqpoints,:) = qpoints_inp(nqpoints_inp,:)

  write(6,*) "q-points"
  do i=1, nqpoints
     write(6,*) qpoints(i,:)
  end do

  open(12, file=basename, status='unknown')

  ! now calculate the band structure for each q-point
  do q=1, nqpoints
     qp = qpoints(q,:)
     
     fc_q = 0.0_wp     
     
     !write(11,*)
     !write(11,*) "qpoint", qp
     
     ! average over all centers to get good statistics
     do j1 = 0, supercell(1)-1 
        do j2 = 0, supercell(2)-1 
           do j3 = 0, supercell(3)-1 

              cell1 = (/j1,j2,j3/)

              call cell_to_cellnum(supercell, cell1, cellnum1)

              
              do i4=1,3
                 do i5=1, 21
                    
                    call compressed_to_normal(supercell, 3 * cellnum1 + i4, i5, ii, jj)
                    
                    call coord_to_cellnum(jj, cellnum2, xyz)
                    call cellnum_to_cell(supercell, cellnum2, cell2)
                    
                    call pbc(supercell,cell1-cell2, cell12)
                    
                    fc_q(i4,xyz) = fc_q(i4,xyz) + fc(ii, i5 ) * &
                         exp(dcmplx(0, 2.0_wp * pi * dot_product(qp, dfloat(cell12))   ) )
                    
                 end do !i5
              end do !i4
              
           end do ! j3
        end do ! j2
     end do ! j1
     
     fc_q = fc_q / product(supercell)

     if( maxval(abs(imag(fc_q))) .gt. 1.0e-10 ) then
        write(6,*) "Error, complex fq_q!"
        !stop
     else
        fc_q_real = dreal(fc_q)
     end if

     ! symmetrize fc_q_real
     do i=1,3
        do j=i+1,3
           fc_q_real(i,j) =0.5_wp * (fc_q_real(i,j) + fc_q_real(j,1) )
           fc_q_real(j,i) = fc_q_real(i,j)
        end do
     end do

     ! test the q-force constant routine for commensurate q-points
     !write(11,*) fc_q_real
     !
     !call system_3d_get_fc_q2(supercell, fc, qp, qp, fc_q2)
     !
     !write(13,*) fc_q2
     !stop

     !  diagonalize 3x3 matrix
     call diagonalize(fc_q_real, eig, eigvec)

     ! for Gamma, compute fourth moment
     if (q .eq. 1 ) then

        ! compute correction to gamma phonons
        if (mom4_flag) then
                      
           !assert that the first q-point given is Gamma
           if(abs(qp(1)) .gt. 1e-10 .and. &
                abs(qp(2)) .gt. 1e-10 .and. &
                abs(qp(3)) .gt. 1e-10 ) then
           
              write(6,*) "First q-point is not Gamma! Cannot compute the fourth moments"
              
           end if
           
           call compute_mom4(eigvec, mom4_gamma)

           do i=1,3
             write(6,*)
              write(6,*) "frequeny_gamma",  sqrt(eig(i))
              write(6,*) "mom2, mom4 ", eig(i),  mom4_gamma(i)

              call estimate_parameters(eig(i), mom4_gamma(i))
           end do


           call compute_mom4_new(eigvec, mom4_gamma)

           write(6,*)
           write(6,*)

           do i=1,3
             write(6,*)
             write(6,*) "frequeny_gamma",  sqrt(eig(i))
             write(6,*) "mom2, mom4 ", eig(i),  mom4_gamma(i)
             
             call estimate_parameters(eig(i), mom4_gamma(i))
           end do

        end if
     end if


     do i=1,3
        if (real(eig(i)) .ge. 0) then
           band(q,i) = sqrt(eig(i))
        else
           band(q,i) = -sqrt(-eig(i))
        end if
     end do !i
     
     write(12,'(6ES18.10)') qp, band(q,:)
     
  end do !q


contains

subroutine compute_mom4(eigvec, mom4_gamma)
  real(kind=wp), intent(in):: eigvec(3,3)
  real(kind=wp), intent(out):: mom4_gamma(3)

  integer:: nqpoints_4_mom
  integer:: i,a, q, i1,i2,i3, b

  !read file     
  open(unit=10, file=infile_mom4, status='old')
  
  read(10,*) nqpoints_4_mom
  
  allocate( qpoints_4_mom(nqpoints_4_mom,3), dyn_mat2(nqpoints_4_mom,3,3,3) )
  
  do i=1,  nqpoints_4_mom
     read(10,*)  qpoints_4_mom(i,:), dyn_mat2(i,:,:,:) 
  end do

  !calculate the fourth moments in the three gamma normal modes
  mom4_gamma = 0.0_wp
  
  ! check eigenvectors
  !write(6,*) "orthogonality of eigenvectors"
  !do a=1,3
  !   do b=1,3
  !      write(6,*) a, b, sum(eigvec(:,a)*eigvec(:,b))
  !   end do
  !end do
  !stop

  do a =1,3 ! gamma normal modes
     do q=1,nqpoints_4_mom ! q-points
        do i1=1,3 ! alpha 
           do i2=1,3 ! alpha'' 
              do i3=1,3 ! alpha' 
                 
                 mom4_gamma(a) = mom4_gamma(a) + eigvec(i1,a) * &
                      eigvec(i3, a) * dyn_mat2(q,i1,i2,i3)
                 
              end do
           end do
        end do
     end do
  end do

  !write(6,*) mom4_gamma
  !write(6,*) product(supercell) 
  !write(6,*) nqpoints_4_mom 
  !write(6,*) mom4_gamma * product(supercell) / nqpoints_4_mom  
  mom4_gamma =  mom4_gamma * product(supercell) / nqpoints_4_mom  

end subroutine compute_mom4

subroutine compute_mom4_new(eigvec, mom4_gamma)
  real(kind=wp), intent(in):: eigvec(3,3)
  real(kind=wp), intent(out):: mom4_gamma(3)

  real(kind=wp):: mom4_gamma_tmp(3,3)
  integer:: nqpoints_4_mom
  integer:: i,a, q, i1,i2,i3, b

  !read file     
  open(unit=10, file=infile_mom4_2, status='old')
  
  read(10,*) mom4_gamma_tmp

  mom4_gamma = 0.0_wp
  
  do a =1,3 ! gamma normal modes
    do i1=1,3 ! alpha 
      do i2=1,3 ! alpha'
                 
        mom4_gamma(a) =  mom4_gamma(a) + eigvec(i1,a) * &
             eigvec(i2,a) * mom4_gamma_tmp(i1,i2)
                 
      end do
    end do
  end do
 
  !mom4_gamma =  mom4_gamma * product(supercell) / (64**2)!nqpoints_4_mom
 
  ! XXX test, remove this
  !mom4_gamma =  mom4_gamma / product(supercell)**2

end subroutine compute_mom4_new

subroutine estimate_parameters(mom2, mom4)
  real(kind=wp), intent(in):: mom2
  real(kind=wp), intent(out):: mom4

  real(kind=wp):: p, q, omega1, omega2, alpha1, alpha2, alpha1_f, &
       alpha2_f, fwhm1_f, fwhm2_f, om(100000), func(100000),&
       mom0
  integer::i
    
  ! estimate parameters in \cos(\omega_0 t) e^{-\alpha_0 t^2}
    !b = -18.0_wp / 13.0_wp * derivative2_tot
    !c = (6.0_wp * derivative2_tot - derivative22_tot) / 13.0_wp 

    !mom2 =  derivative2_tot / my_SI 
    !mom4 =  derivative22_tot / (my_SI**2) 

    p = -mom2  
    q = (mom4 - mom2 ** 2) / 8
    
    if(p **2 / 4 .lt. q ) then
       write(6,*) "problem with fitting, complex roots!"
    else
       ! first root
       alpha1 = -p / 2 + sqrt((p **2) / 4 - q)
       ! second root
       alpha2 = -p / 2 - sqrt((p **2) / 4 - q)
    end if
    
    !omega1 = sqrt(mom2 -2.0_wp * alpha1 ) * (hbar * cm)  ! cm-1
    !omega1 = sqrt(2.0_wp * alpha1 - mom2)
    omega1 = sqrt(mom2 -2.0_wp * alpha1 )    

    !alpha1 = 0.5_wp * (s1  -derivative2_tot)
    !alpha1_f = 1.0_wp / (4.0_wp * alpha1)
    !alpha1_f = 1.0_wp / (4.0_wp * alpha1 * (hbar * cm)**2) ! cm^2
    alpha1_f = 1.0_wp / (4.0_wp * alpha1 ) 
    fwhm1_f = 2.0_wp * sqrt(log(2.0_wp) / alpha1_f)
    
    !omega2 = sqrt(mom2 -2.0_wp * alpha2 ) * (hbar * cm)  ! cm-1
    omega2 = sqrt(mom2 -2.0_wp * alpha2 ) 
    !alpha2_f = 1.0_wp / (4.0_wp * alpha2 * (hbar * cm)**2) !cm^2    
    alpha2_f = 1.0_wp / (4.0_wp * alpha2 ) 
    fwhm2_f = 2.0_wp * sqrt(log(2.0_wp) / alpha2_f)
    
    write(6,*) "fitted first root, omega:", omega1  ,"alpha", alpha1 
    write(6,*) "alpha' in fourier space",   alpha1_f, "fwhm", fwhm1_f

    write(6,*) "fitted second root, omega:", omega2  ,"alpha", alpha2 
    write(6,*) "alpha' in fourier space",   alpha2_f, "fwhm", fwhm2_f

    !do i=1, 100000
    !   om(i) = 20.0_wp * (i-1) / 100000 -10.0_wp
    !   func(i) = exp(-alpha2_f * (om(i) - omega2)**2)
    !end do
    !
    !mom0 = compute_moments(func, om, 0)
    !mom2 = compute_moments(func, om, 2)
    !mom4 = compute_moments(func, om, 4)
    !
    !write(6,*) "zeroth moment of Gaussian", mom0  
    !write(6,*) "second moment of Gaussian", mom2, mom2 / mom0 
    !write(6,*) "fourth moment of Gaussian",  mom4, mom4 / mom0 
    
  end subroutine estimate_parameters

  !subroutine test_fc_q_main(supercell, fc_q, q1, )
  !  integer, intent(in):: supercell(3)
  !  real(kind=wp), intent(out):: fc_q(3,3)
  !end subroutine test_fc_q_main
  
end program bandstructure
